{"title":"JS不可變物件","slug":"JS不可變物件","date":"2019-07-11T11:26:18.000Z","updated":"2019-07-11T05:19:45.966Z","comments":true,"path":"api/articles/2019/07/11/JS不可變物件.json","photos":[],"link":"","excerpt":"","content":"<h1 id=\"在JS應對髒值檢查\"><a href=\"#在JS應對髒值檢查\" class=\"headerlink\" title=\"在JS應對髒值檢查\"></a>在JS應對髒值檢查</h1><p>在不同前端框架中都有各自的髒值發現算法，而大多數都是基於引用對比。</p><p>在一般數值或字串，這種原生物件/類型上，都是不可變的。因此每次改變都會更新其引用/指針，除了數組和物件(Array,Object)這兩個特殊的類件。</p><p>使用 <code>Array.push</code> 和 <code>Array.splice</code> 或直更改 Object 的內容，都是基於子物件/子類型的內容，並不會對根引用/針對作出變更。因此大部分情況下，都不會觸發髒值檢查。</p><p>如果要對 Array 和 Object 重新構造，可以使用以下方法。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// es5</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> rawArray = [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> rawObject = &#123;<span class=\"attr\">a</span>:<span class=\"string\">'a'</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> newArray = [].concat(rawArray);</span><br><span class=\"line\"><span class=\"keyword\">const</span> newObject = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, rawObject);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rawArray === newArray); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rawObject === newObject); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// es6</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> newES6Array = [...rawArray];</span><br><span class=\"line\"><span class=\"keyword\">const</span> pushArray = [...rawArray, <span class=\"number\">7</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> unshiftArray = [<span class=\"number\">7</span>, ...rawArray];</span><br><span class=\"line\"><span class=\"keyword\">const</span> newES6Object = &#123;...rawObject&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rawArray === unshiftArray); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rawObject === newES6Object); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure><p>別了以上的方法構建新的實例外，別一做法是使用 getter 返回一個全新的類型。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title = <span class=\"string\">'title'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">objTitle = &#123;</span><br><span class=\"line\">  title: <span class=\"keyword\">this</span>.title === <span class=\"string\">'title'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">get getterObjTitle() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'getterObj'</span>, <span class=\"keyword\">this</span>.obj.title);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    title: <span class=\"keyword\">this</span>.title === <span class=\"string\">'title'</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>以上方法如果直接拿objTitle是不會得到更新。</p>","prev":null,"next":{"title":"處理圖像的TypedArray和一般的UInt8Array區別","link":"/2019/06/26/處理圖像的TypedArray和一般的UInt8Array區別"},"categories":[{"name":"JavaScript","slug":"JavaScript","count":2,"path":"api/categories/JavaScript.json"}],"tags":[]}