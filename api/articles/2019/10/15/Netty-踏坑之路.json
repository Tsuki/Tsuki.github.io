{"title":"Netty 踏坑之路","slug":"Netty-踏坑之路","date":"2019-10-15T10:39:45.000Z","updated":"2019-10-15T10:00:20.688Z","comments":true,"path":"api/articles/2019/10/15/Netty-踏坑之路.json","photos":[],"link":"","excerpt":"BytebufBytebuf 是 Netty 內部的一個處理原始數據類型，這個類型會針會 jvm 的回收機制優化同時抽象出 zero-copy 的數據類型。readSlice vs readBytesreadSlice 是反正 Bytebuf的 視圖，但建立自己的 readIndex 和 writeIndex. 在視圖讀寫數據不會影響本來的Index.readBytes 是返回新的 Bytebuf，申請後 需要自行 release 以釋放數據，除止內存洩漏。slice vs duplicate vs copyslice() 方法從原始 ByteBuf 中截取一段，這段數據是從 readerIndex 到 writeIndex，同時，返回的新的 ByteBuf 的最大容量 maxCapacity 為原始 ByteBuf 的 readableBytes()duplicate() 方法把整個 ByteBuf 都截取出來，包括所有的數據，指針信息slice() 方法與 duplicate() 方法的相同點是：底層內存以及引用計數與原始的 ByteBuf 共享，也就是說經過 slice() 或者 duplicate() 返回的 ByteBuf 調用 write 系列方法都會影響到 原始的 ByteBuf，但是它們都維持著與原始 ByteBuf 相同的內存引用計數和不同的讀寫指針slice() 方法與 duplicate() 不同點就是：slice() 只截取從 readerIndex 到 writerIndex 之間的數據，它返回的 ByteBuf 的最大容量被限制到 原始 ByteBuf 的 readableBytes(), 而 duplicate() 是把整個 ByteBuf 都與原始的 ByteBuf 共享slice() 方法與 duplicate() 方法不會拷貝數據，它們只是通過改變讀寫指針來改變讀寫的行為，而最後一個方法 copy() 會直接從原始的 ByteBuf 中拷貝所有的信息，包括讀寫指針以及底層對應的數據，因此，往 copy() 返回的 ByteBuf 中寫數據不會影響到原始的 ByteBufslice() 和 duplicate() 不會改變 ByteBuf 的引用計數，所以原始的 ByteBuf 調用 release() 之後發現引用計數為零，就開始釋放內存，調用這兩個方法返回的 ByteBuf 也會被釋放，這個時候如果再對它們進行讀寫，就會報錯。因此，我們可以通過調用一次 retain() 方法 來增加引用，表示它們對應的底層的內存多了一次引用，引用計數為2，在釋放內存的時候，需要調用兩次 release() 方法，將引用計數降到零，才會釋放內存這三個方法均維護著自己的讀寫指針，與原始的 ByteBuf 的讀寫指針無關，相互之間不受影響Ref：数据传输载体 ByteBuf 介绍","content":"<h2 id=\"Bytebuf\"><a href=\"#Bytebuf\" class=\"headerlink\" title=\"Bytebuf\"></a>Bytebuf</h2><p>Bytebuf 是 Netty 內部的一個處理原始數據類型，這個類型會針會 jvm 的回收機制優化同時抽象出 zero-copy 的數據類型。</p><h4 id=\"readSlice-vs-readBytes\"><a href=\"#readSlice-vs-readBytes\" class=\"headerlink\" title=\"readSlice vs readBytes\"></a>readSlice vs readBytes</h4><p>readSlice 是反正 Bytebuf的 視圖，但建立自己的 readIndex 和 writeIndex. 在視圖讀寫數據不會影響本來的Index.</p><p>readBytes 是返回新的 Bytebuf，申請後 需要自行 release 以釋放數據，除止內存洩漏。</p><h4 id=\"slice-vs-duplicate-vs-copy\"><a href=\"#slice-vs-duplicate-vs-copy\" class=\"headerlink\" title=\"slice vs duplicate vs copy\"></a>slice vs duplicate vs copy</h4><ol><li>slice() 方法從原始 ByteBuf 中截取一段，這段數據是從 readerIndex 到 writeIndex，同時，返回的新的 ByteBuf 的最大容量 maxCapacity 為原始 ByteBuf 的 readableBytes()</li><li>duplicate() 方法把整個 ByteBuf 都截取出來，包括所有的數據，指針信息</li><li>slice() 方法與 duplicate() 方法的相同點是：底層內存以及引用計數與原始的 ByteBuf 共享，也就是說經過 slice() 或者 duplicate() 返回的 ByteBuf 調用 write 系列方法都會影響到 原始的 ByteBuf，但是它們都維持著與原始 ByteBuf 相同的內存引用計數和不同的讀寫指針</li><li>slice() 方法與 duplicate() 不同點就是：slice() 只截取從 readerIndex 到 writerIndex 之間的數據，它返回的 ByteBuf 的最大容量被限制到 原始 ByteBuf 的 readableBytes(), 而 duplicate() 是把整個 ByteBuf 都與原始的 ByteBuf 共享</li><li>slice() 方法與 duplicate() 方法不會拷貝數據，它們只是通過改變讀寫指針來改變讀寫的行為，而最後一個方法 copy() 會直接從原始的 ByteBuf 中拷貝所有的信息，包括讀寫指針以及底層對應的數據，因此，往 copy() 返回的 ByteBuf 中寫數據不會影響到原始的 ByteBuf</li><li>slice() 和 duplicate() 不會改變 ByteBuf 的引用計數，所以原始的 ByteBuf 調用 release() 之後發現引用計數為零，就開始釋放內存，調用這兩個方法返回的 ByteBuf 也會被釋放，這個時候如果再對它們進行讀寫，就會報錯。因此，我們可以通過調用一次 retain() 方法 來增加引用，表示它們對應的底層的內存多了一次引用，引用計數為2，在釋放內存的時候，需要調用兩次 release() 方法，將引用計數降到零，才會釋放內存</li><li>這三個方法均維護著自己的讀寫指針，與原始的 ByteBuf 的讀寫指針無關，相互之間不受影響</li></ol><p>Ref：</p><p><a href=\"https://my.oschina.net/funcy/blog/2250198\" target=\"_blank\" rel=\"noopener\">数据传输载体 ByteBuf 介绍</a></p>","prev":{"title":"2019春遊日本九州-長崎/佐世保","link":"/2019/10/20/2019springJP"},"next":{"title":"JS不可變物件","link":"/2019/07/11/JS不可變物件"},"categories":[],"tags":[]}