{"name":"JavaScript","slug":"JavaScript","count":2,"postlist":[{"_id":"cjxdbk8cp0001mvk69ppnmmmn","title":"處理圖像的TypedArray和一般的UInt8Array區別","slug":"處理圖像的TypedArray和一般的UInt8Array區別","date":"2019-06-26T21:05:49.000Z","updated":"2019-06-26T14:13:07.012Z","comments":true,"permalink":"/2019/06/26/處理圖像的TypedArray和一般的UInt8Array區別/","path":"api/articles/處理圖像的TypedArray和一般的UInt8Array區別.json","excerpt":"<p>在 ES2015上加入了 TypedArray 的處理，以處理 buffer 帶來的問題，而其中 Uint8 有兩種類型和處理方法，分別是Uint8Array，Uint8ClampedArray。</p><p>前者是無條件捨去小數（ToUint8），後者是使用奇進偶捨（ToUint8Clamp ）的進位方法。</p><p>其次前者不會對二補位的負數作溢出處理，後者會對小於０和大於２５５的數字作出歸０或２５５。</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Int8Array();</span><br><span class=\"line\">Uint8Array();</span><br><span class=\"line\">Uint8ClampedArray();</span><br><span class=\"line\">Int16Array();</span><br><span class=\"line\">Uint16Array();</span><br><span class=\"line\">Int32Array();</span><br><span class=\"line\">Uint32Array();</span><br><span class=\"line\">Float32Array();</span><br><span class=\"line\">Float64Array();</span><br><span class=\"line\">BigInt64Array();</span><br><span class=\"line\">BigUint64Array();</span><br></pre></td></tr></table></figure><p>別外在<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/ImageData/ImageData\" target=\"_blank\" rel=\"noopener\"><code>ImageData()</code></a>的 <code>array</code> 是注明 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray\" target=\"_blank\" rel=\"noopener\"><code>Uint8ClampedArray</code></a> 。</p><h3 id=\"ToUint8-argument\"><a href=\"#ToUint8-argument\" class=\"headerlink\" title=\"ToUint8 ( argument )\"></a>ToUint8 ( argument )</h3><p>The abstract operation ToUint8 converts argument to one of 28 integer values in the range 0 through 255, inclusive. This abstract operation functions as follows:</p><ol><li>Let <em>number</em> be <a href=\"http://www.ecma-international.org/ecma-262/6.0/index.html#sec-tonumber\" target=\"_blank\" rel=\"noopener\">ToNumber</a>(<em>argument</em>).</li><li><a href=\"http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt\" target=\"_blank\" rel=\"noopener\">ReturnIfAbrupt</a>(<em>number</em>).</li><li>If <em>number</em> is <strong>NaN</strong>, <strong>+0</strong>, <strong>−0</strong>, <strong>+∞</strong>, or <strong>−∞</strong>, return <strong>+0</strong>.</li><li>Let <em>int</em> be the mathematical value that is the same sign as <em>number</em> and whose magnitude is <a href=\"http://www.ecma-international.org/ecma-262/6.0/index.html#sec-algorithm-conventions\" target=\"_blank\" rel=\"noopener\">floor</a>(<a href=\"http://www.ecma-international.org/ecma-262/6.0/index.html#sec-algorithm-conventions\" target=\"_blank\" rel=\"noopener\">abs</a>(<em>number</em>)).</li><li>Let <em>int8bit</em> be <em>int</em> <a href=\"http://www.ecma-international.org/ecma-262/6.0/index.html#sec-algorithm-conventions\" target=\"_blank\" rel=\"noopener\">modulo</a> 28.</li><li>Return <em>int8bit</em>.</li></ol><h3 id=\"ToUint8Clamp-argument\"><a href=\"#ToUint8Clamp-argument\" class=\"headerlink\" title=\"ToUint8Clamp ( argument )\"></a>ToUint8Clamp ( argument )</h3><p>The abstract operation ToUint8Clamp converts argument to one of 28 integer values in the range 0 through 255, inclusive. This abstract operation functions as follows:</p>","keywords":null,"content":null,"text":"在 ES2015上加入了 TypedArray 的處理，以處理 buffer 帶來的問題，而其中 Uint8 有兩種類型和處理方法，分別是Uint8Array，Uint8ClampedArray。前者是無條件捨去小數（ToUint8），後者是使用奇進偶捨（ToUint8Clamp","link":"","raw":null,"photos":[],"source":"_posts/2019/06/26-處理圖像的TypedArray和一般的UInt8Array區別.md","categories":[{"name":"JavaScript","slug":"JavaScript","count":2,"path":"api/categories/JavaScript.json"}],"tags":[]},{"_id":"cjxy83ur30000iuqvimd7k64c","title":"JS不可變物件","slug":"JS不可變物件","date":"2019-07-11T11:26:18.000Z","updated":"2019-07-11T05:19:45.966Z","comments":true,"permalink":"/2019/07/11/JS不可變物件/","path":"api/articles/JS不可變物件.json","excerpt":"<h1 id=\"在JS應對髒值檢查\"><a href=\"#在JS應對髒值檢查\" class=\"headerlink\" title=\"在JS應對髒值檢查\"></a>在JS應對髒值檢查</h1><p>在不同前端框架中都有各自的髒值發現算法，而大多數都是基於引用對比。</p><p>在一般數值或字串，這種原生物件/類型上，都是不可變的。因此每次改變都會更新其引用/指針，除了數組和物件(Array,Object)這兩個特殊的類件。</p><p>使用 <code>Array.push</code> 和 <code>Array.splice</code> 或直更改 Object 的內容，都是基於子物件/子類型的內容，並不會對根引用/針對作出變更。因此大部分情況下，都不會觸發髒值檢查。</p><p>如果要對 Array 和 Object 重新構造，可以使用以下方法。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// es5</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> rawArray = [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> rawObject = &#123;<span class=\"attr\">a</span>:<span class=\"string\">'a'</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> newArray = [].concat(rawArray);</span><br><span class=\"line\"><span class=\"keyword\">const</span> newObject = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, rawObject);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rawArray === newArray); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rawObject === newObject); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// es6</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> newES6Array = [...rawArray];</span><br><span class=\"line\"><span class=\"keyword\">const</span> pushArray = [...rawArray, <span class=\"number\">7</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> unshiftArray = [<span class=\"number\">7</span>, ...rawArray];</span><br><span class=\"line\"><span class=\"keyword\">const</span> newES6Object = &#123;...rawObject&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rawArray === unshiftArray); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rawObject === newES6Object); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure><p>別了以上的方法構建新的實例外，別一做法是使用 getter 返回一個全新的類型。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title = <span class=\"string\">'title'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">objTitle = &#123;</span><br><span class=\"line\">  title: <span class=\"keyword\">this</span>.title === <span class=\"string\">'title'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">get getterObjTitle() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'getterObj'</span>, <span class=\"keyword\">this</span>.obj.title);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    title: <span class=\"keyword\">this</span>.title === <span class=\"string\">'title'</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>以上方法如果直接拿objTitle是不會得到更新。</p>","keywords":null,"content":null,"text":"在JS應對髒值檢查在不同前端框架中都有各自的髒值發現算法，而大多數都是基於引用對比。在一般數值或字串，這種原生物件/類型上，都是不可變的。因此每次改變都會更新其引用/指針，除了數組和物件(Array,Object)這兩個特殊的類件。使用 Array.push 和 Array.sp","link":"","raw":null,"photos":[],"source":"_posts/2019/07/11-JS不可變物件.md","categories":[{"name":"JavaScript","slug":"JavaScript","count":2,"path":"api/categories/JavaScript.json"}],"tags":[]}]}