{"total":65,"pageSize":10,"pageCount":7,"data":[{"_id":"cjugy0vku0000ilp4glt1f9no","title":"記一次使用 Makefile 和 Docker 的坑","slug":"記一次使用-makefile-和-docker-的坑","date":"2019-04-13T20:00:07.000Z","updated":"2019-04-14T13:06:14.198Z","comments":true,"permalink":"/2019/04/13/記一次使用-makefile-和-docker-的坑/","path":"api/articles/記一次使用-makefile-和-docker-的坑.json","excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>在使用 make 和 Docker 構建發佈影像時，重構了一下 Makefile 而引起不算是 Bug 的 bug.</p><h3 id=\"事原\"><a href=\"#事原\" class=\"headerlink\" title=\"事原\"></a>事原</h3><p>Makefile 指令如果在用同的文件夾突特時 會出現 <code>make: 指令 is up to date.</code> 這樣奇怪的信訊？（？</p><p>別外加上在 Docker build 的時候 make 指令的 step 出現 up to date 以為是被 cached。</p><p>最後在 <code>COPY --from=build-dev</code> 時找不到文件 出現 <code>/var/lib/docker/overlay2/</code> 找不到文件 而不是在 docker 對應路徑。</p><h3 id=\"解決\"><a href=\"#解決\" class=\"headerlink\" title=\"解決\"></a>解決</h3><p>在 Makefile 裹給指令 加上 <code>.PHONY</code> 注解。</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A phony target is one that is not really the name of a file; rather it is just a name for a recipe to be executed when you make an explicit request. There are two reasons to use a phony target: to avoid a conflict with a file of the same name, and to improve performance.</span><br><span class=\"line\"></span><br><span class=\"line\">If you write a rule whose recipe will not create the target file, the recipe will be executed every time the target comes up for remaking.</span><br></pre></td></tr></table></figure><p>GNU默认makefile target是一个文件，因此他会先检测同级目录下是否已存在这个文件，如果存在，则会abort掉make 进程，但目标不是文件的话，则会出现up to date的情况，这种情况需要.PHONY来避免问题的出现，phony的意思是“赝品”，在这里可以形象的理解成“不是文件”。</p>","keywords":null,"content":null,"text":"前言在使用 make 和 Docker 構建發佈影像時，重構了一下 Makefile 而引起不算是 Bug 的 bug.事原Makefile 指令如果在用同的文件夾突特時 會出現 make: 指令 is up to date. 這樣奇怪的信訊？（？別外加上在 Docker bui","link":"","raw":null,"photos":[],"source":"_posts/2019/04/13-記一次使用-makefile-和-docker-的坑.md","categories":[{"name":"Docker","slug":"Docker","count":1,"path":"api/categories/Docker.json"},{"name":"Linux","slug":"Docker/Linux","count":1,"path":"api/categories/Docker/Linux.json"}],"tags":[]},{"_id":"cju2ndcof0005itmguh1qumro","title":"把OPENSSL 私鑰轉換成 RSA 私鈅","slug":"把OPENSSL-私鑰轉換成-RSA-私鈅","date":"2019-04-04T19:43:03.000Z","updated":"2019-04-04T12:59:22.508Z","comments":true,"permalink":"/2019/04/04/把OPENSSL-私鑰轉換成-RSA-私鈅/","path":"api/articles/把OPENSSL-私鑰轉換成-RSA-私鈅.json","excerpt":"","keywords":null,"content":"<h2 id=\"事原\"><a href=\"#事原\" class=\"headerlink\" title=\"事原\"></a>事原</h2><p>由於 OpenSSH version 7.9p1 修改了 預設的私鑰輸出格式，</p><p>從 <code>-----BEGIN RSA PRIVATE KEY-----</code> 改成 <code>-----BEGIN OPENSSH PRIVATE KEY-----</code></p><p>所以 Jetbrain 的全家桶都不能讀取正確的私鑰。</p><h3 id=\"指令-把原有的私鑰-重新導出\"><a href=\"#指令-把原有的私鑰-重新導出\" class=\"headerlink\" title=\"指令 - 把原有的私鑰 重新導出\"></a>指令 - 把原有的私鑰 重新導出</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp ~/.ssh/id_rsa ~/.ssh/id_rsa.bak</span><br><span class=\"line\">ssh-keygen -p -m PEM -f ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><h3 id=\"指令-重新生成新的-PEM-格式私鑰\"><a href=\"#指令-重新生成新的-PEM-格式私鑰\" class=\"headerlink\" title=\"指令 - 重新生成新的 PEM 格式私鑰\"></a>指令 - 重新生成新的 PEM 格式私鑰</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp ~/.ssh/id_rsa ~/.ssh/id_rsa.bak</span><br><span class=\"line\"></span><br><span class=\"line\">ssh-keygen -m PEM -C &quot;email&quot;</span><br><span class=\"line\">或</span><br><span class=\"line\">ssh-keygen -t rsa -b 4096 -m pem -C &quot;email&quot;</span><br></pre></td></tr></table></figure>","text":"事原由於 OpenSSH version 7.9p1 修改了 預設的私鑰輸出格式，從 -----BEGIN RSA PRIVATE KEY----- 改成 -----BEGIN OPENSSH PRIVATE KEY-----所以 Jetbrain 的全家桶都不能讀取正確的私鑰。","link":"","raw":null,"photos":[],"source":"_posts/2019/04/04-把OPENSSL-私鑰轉換成-RSA-私鈅.md","categories":[],"tags":[]},{"_id":"cju2ndcof0004itmg0kd09oa7","title":"SS PAC模式白名單","slug":"Shadowsocks-白名單","date":"2019-03-05T20:36:46.000Z","updated":"2019-04-04T12:59:22.508Z","comments":true,"permalink":"/2019/03/05/Shadowsocks-白名單/","path":"api/articles/Shadowsocks-白名單.json","excerpt":"","keywords":null,"content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>使用 SS 但又不想使用全局，避免大量跑光流量，需要定制白名單給 google / youtube。</p><h1 id=\"白名單制作\"><a href=\"#白名單制作\" class=\"headerlink\" title=\"白名單制作\"></a>白名單制作</h1><p>由於 SS 沒有自帶白名單模式，而且自帶的 gfwlist.txt 內有避開國內的域名，所以需要先制作一分全局的 gfwlist.txt</p><p><code>||*</code> 是全局的規則，我們需要先做base64處理，下面是處理好的 <code>gfwlist.txt</code> 和 gist 地址。</p><p>之後需要放到 Github 或其他地方寄存。</p><script src=\"https://gist.github.com/Tsuki/67e448466baf453a9a9eca4a6d55592a.js\"></script><p><a href=\"https://gist.githubusercontent.com/Tsuki/67e448466baf453a9a9eca4a6d55592a/raw/4e262236bf1cb21348612274fbd5b5cf3da1afe7/sswl.txt\" target=\"_blank\" rel=\"noopener\">https://gist.githubusercontent.com/Tsuki/67e448466baf453a9a9eca4a6d55592a/raw/4e262236bf1cb21348612274fbd5b5cf3da1afe7/sswl.txt</a></p><p>之後在 User-rule 下加入想要白名單的域名。</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@@googlevideo.com</span><br><span class=\"line\">@@youtube.com</span><br><span class=\"line\">@@google.com</span><br><span class=\"line\">@@ytimg.com</span><br></pre></td></tr></table></figure>","text":"前言使用 SS 但又不想使用全局，避免大量跑光流量，需要定制白名單給 google / youtube。白名單制作由於 SS 沒有自帶白名單模式，而且自帶的 gfwlist.txt 內有避開國內的域名，所以需要先制作一分全局的 gfwlist.txt||* 是全局的規則，我們需要","link":"","raw":null,"photos":[],"source":"_posts/2019/03/05-Shadowsocks-白名單.md","categories":[],"tags":[]},{"_id":"cju2ndcod0002itmgp8vj8c1d","title":"Async/Await Golang式寫法","slug":"Async-Await-golang式寫法","date":"2019-02-09T11:28:10.000Z","updated":"2019-04-04T12:59:22.508Z","comments":true,"permalink":"/2019/02/09/Async-Await-golang式寫法/","path":"api/articles/Async-Await-golang式寫法.json","excerpt":"<p>使用 promise 和 result pair 避免 try-catch style.</p><p>Javascript 例子</p><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// to.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">to</span>(<span class=\"params\">promise: <span class=\"built_in\">Promise</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> promise</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [<span class=\"literal\">null</span>, data];</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> [err]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> to <span class=\"keyword\">from</span> <span class=\"string\">'to'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> AccountComponent <span class=\"keyword\">implements</span> OnInit, OnChanges&#123;</span><br><span class=\"line\">    <span class=\"keyword\">async</span> ngOnChanges(changes: SimpleChanges) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO check change</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> err, result;</span><br><span class=\"line\">        [err, result] = <span class=\"keyword\">await</span> to(<span class=\"keyword\">this</span>.httpService.listAccount(<span class=\"keyword\">this</span>.data).toPromise());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err != <span class=\"literal\">null</span> &amp;&amp; err <span class=\"keyword\">instanceof</span> HttpErrorResponse) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// err in</span></span><br><span class=\"line\">          <span class=\"keyword\">this</span>.notice.create(<span class=\"string\">'error'</span>, err.error.msg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>以下是 Golang 的寫法</p><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> err, result := httpService.listAccount(data); err != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// process...</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// error handling...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><a href=\"https://blog.grossman.io/how-to-write-async-await-without-try-catch-blocks-in-javascript/\" target=\"_blank\" rel=\"noopener\">How to write async await without try-catch blocks in Javascript - dima</a></p><p><a href=\"https://segmentfault.com/a/1190000011802045\" target=\"_blank\" rel=\"noopener\">从不用 try-catch 实现的 async/await 语法说错误处理</a></p><p>題外話 – try-catch 的惡魔</p><p><a href=\"http://teddy-chen-tw.blogspot.com/2011/05/checked-or-unchecked-exceptions-1.html\" target=\"_blank\" rel=\"noopener\">Checked or unchecked exceptions (1)</a></p>","keywords":null,"content":null,"text":"使用 promise 和 result pair 避免 try-catch style.Javascript 例子1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>// to.ts<br>export default function to(prom","link":"","raw":null,"photos":[],"source":"_posts/2019/02/09-Async-Await-golang式寫法.md","categories":[],"tags":[]},{"_id":"cju2ndcn50001itmgxs935t3j","title":"Android 中文在地化機制","slug":"Android-中文在地化機制","date":"2019-02-02T12:03:44.000Z","updated":"2019-04-04T12:59:22.508Z","comments":true,"permalink":"/2019/02/02/Android-中文在地化機制/","path":"api/articles/Android-中文在地化機制.json","excerpt":"","keywords":null,"content":"<h3 id=\"在-Andorid-7-之前，\"><a href=\"#在-Andorid-7-之前，\" class=\"headerlink\" title=\"在 Andorid 7 之前，\"></a>在 Andorid 7 之前，</h3><ul><li><code>zh-CN</code> (簡體)</li><li><code>zh-TW</code> (繁體)</li><li>特殊子集:<ul><li><code>zh-SG</code> (簡體)</li><li><code>zh-HK</code> (繁體)</li><li><code>zh-MO</code> (繁體)</li></ul></li></ul><h3 id=\"在-Android-7-及之後，-喵喵喵？\"><a href=\"#在-Android-7-及之後，-喵喵喵？\" class=\"headerlink\" title=\"在 Android 7 及之後，(喵喵喵？)\"></a>在 Android 7 及之後，(喵喵喵？)</h3><ul><li><code>zh-Hans-CN</code> (簡體)</li><li><code>zh-Hans-MO</code> (簡體)</li><li><code>zh-Hans-HK</code> (簡體)</li><li><code>zh-Hans-SG</code> (簡體)</li><li><code>zh-Hant-TW</code> (繁體)</li><li><code>zh-Hant-HK</code> (繁體)</li><li><code>zh-Hant-MO</code> (繁體)</li></ul><p>###Android 7 Fallback 機制</p><p><code>zh-Hans-*</code> 退回到 <code>zh</code></p><p><code>zh-Hant-*</code> 退回到 <code>zh-Hant (zh-rTW)</code></p><p>而 <code>zh-Hans-MO</code> 和 <code>zh-Hans-HK</code> 需要指定 <code>values-b+zh+Hans+HK/MO</code> 再退回 <code>zh-Hans-*</code> 處理</p><p><a href=\"https://gist.github.com/amake/0ac7724681ac1c178c6f95a5b09f03ce#new-locales-vs-old-locales-chinese\" target=\"_blank\" rel=\"noopener\">Correct localization on Android 7</a></p><p><a href=\"https://developer.android.com/guide/topics/resources/multilingual-support\" target=\"_blank\" rel=\"noopener\">Language and locale resolution overview</a></p>","text":"在 Andorid 7 之前，zh-CN (簡體)zh-TW (繁體)特殊子集:zh-SG (簡體)zh-HK (繁體)zh-MO (繁體)在 Android 7 及之後，(喵喵喵？)zh-Hans-CN (簡體)zh-Hans-MO (簡體)zh-Hans-HK (簡體)zh-","link":"","raw":null,"photos":[],"source":"_posts/2019/02/02-Android-中文在地化機制.md","categories":[],"tags":[]},{"_id":"cju2ndcoe0003itmgdvroyup0","title":"Android 文件保存和索引","slug":"Android-文件保存和索引","date":"2019-02-02T12:02:58.000Z","updated":"2019-04-04T12:59:22.508Z","comments":true,"permalink":"/2019/02/02/Android-文件保存和索引/","path":"api/articles/Android-文件保存和索引.json","excerpt":"","keywords":null,"content":"<h3 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h3><p>Android 在保存文件後，如果不在索引目錄下是不會自動建立索引，需要調用 <code>MediaScanner</code> 發出一個廣播和指定目錄或文件的指令才會實行。</p><p>實作 <code>MediaScannerConnectionClient</code> 類，發出掃描指令並在完成後斷開連接。</p><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingleMediaScanner</span></span>(<span class=\"keyword\">val</span> context: Context, <span class=\"keyword\">val</span> file: File) :</span><br><span class=\"line\">  MediaScannerConnection.MediaScannerConnectionClient &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> mediaScannerConnection</span><br><span class=\"line\">    <span class=\"keyword\">by</span> lazy &#123; MediaScannerConnection(context, <span class=\"keyword\">this</span>) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onMediaScannerConnected</span><span class=\"params\">()</span></span> =</span><br><span class=\"line\">    mediaScannerConnection.scanFile(file.absolutePath, <span class=\"literal\">null</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onScanCompleted</span><span class=\"params\">(path: <span class=\"type\">String</span>?, uri: <span class=\"type\">Uri</span>?)</span></span> =</span><br><span class=\"line\">    mediaScannerConnection.disconnect()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> Context.<span class=\"title\">takeScreenshot</span><span class=\"params\">(bitmap: <span class=\"type\">Bitmap</span>)</span></span>: String? &#123;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> mediaStorageDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES)</span><br><span class=\"line\">  <span class=\"keyword\">val</span> timestamp = SimpleDateFormat(<span class=\"string\">\"yyyyMMdd_HHmmss\"</span>).format(Date())</span><br><span class=\"line\">  <span class=\"keyword\">val</span> mediaFile = File(<span class=\"string\">\"<span class=\"subst\">$&#123;mediaStorageDir.path&#125;</span><span class=\"subst\">$&#123;File.separator&#125;</span><span class=\"variable\">$timestamp</span>.jpg\"</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> compress = <span class=\"literal\">false</span></span><br><span class=\"line\">  doAsync &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mediaStorageDir.exists() &amp;&amp; !mediaStorageDir.mkdirs()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span><span class=\"symbol\">@doAsync</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Timber.d(<span class=\"string\">\"screenshot: file <span class=\"subst\">$&#123;mediaStorageDir.path&#125;</span><span class=\"subst\">$&#123;File.separator&#125;</span><span class=\"variable\">$timestamp</span>.jpg\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> fos = FileOutputStream(mediaFile)</span><br><span class=\"line\">    compress = bitmap.compress(Bitmap.CompressFormat.JPEG, <span class=\"number\">90</span>, fos)</span><br><span class=\"line\">    fos.close()</span><br><span class=\"line\">    SingleMediaScanner(<span class=\"keyword\">this</span><span class=\"symbol\">@takeScreenshot</span>, mediaStorageDir)</span><br><span class=\"line\">  &#125;.<span class=\"keyword\">get</span>()</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">if</span> (compress) mediaFile.toString() <span class=\"keyword\">else</span> <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","text":"索引Android 在保存文件後，如果不在索引目錄下是不會自動建立索引，需要調用 MediaScanner 發出一個廣播和指定目錄或文件的指令才會實行。實作 MediaScannerConnectionClient 類，發出掃描指令並在完成後斷開連接。1<br>2<br>3<br","link":"","raw":null,"photos":[],"source":"_posts/2019/02/02-Android-文件保存和索引.md","categories":[],"tags":[]},{"_id":"cju2ndcid0000itmgloe9qfx7","title":"Android requestedOrientation 坑","slug":"Android-requestedOrientation-坑","date":"2019-01-30T14:42:39.000Z","updated":"2019-04-04T12:59:22.508Z","comments":true,"permalink":"/2019/01/30/Android-requestedOrientation-坑/","path":"api/articles/Android-requestedOrientation-坑.json","excerpt":"","keywords":null,"content":"<p>如果在 Activity on Create 時 配置 <code>requestedOrientation</code> 等動作時會觸發 view 重新渲染，會令 view有機率發生奇怪的 dead thread 等情況。<code>Handler sending message to a Handler on a dead thread</code></p><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_PORTRAIT</span><br></pre></td></tr></table></figure><p>正確的做法是在 <code>AndroidManifest.xml</code> 上加入 <code>android:screenOrientation=&quot;portrait&quot;</code> 。</p><p><a href=\"https://developer.android.com/guide/topics/resources/runtime-changes\" target=\"_blank\" rel=\"noopener\">Documentation: Handle configuration changes</a></p>","text":"如果在 Activity on Create 時 配置 requestedOrientation 等動作時會觸發 view 重新渲染，會令 view有機率發生奇怪的 dead thread 等情況。Handler sending message to a Handler on a","link":"","raw":null,"photos":[],"source":"_posts/2019/01/30-Android-requestedOrientation-坑.md","categories":[],"tags":[]},{"_id":"cjqgchdq90000iwnqnxhlrlja","title":"選擇SFP的ONU端口","slug":"選擇SFP的ONU端口","date":"2019-01-03T13:36:40.000Z","updated":"2019-01-03T08:24:29.711Z","comments":true,"permalink":"/2019/01/03/選擇SFP的ONU端口/","path":"api/articles/選擇SFP的ONU端口.json","excerpt":"<h2 id=\"SFP接口\"><a href=\"#SFP接口\" class=\"headerlink\" title=\"SFP接口\"></a>SFP接口</h2><p>現時的路由器/交換器在需要接入光纖的時候，一般需要使用上 SFP 接口。</p><p>SFP 的接口比上一代的 GBIC 接口要小一點，這樣前端面版就可以接入更多的光纖。</p><p>SFP 接口分別有兩種制式，接 1G 或以下的 SFP 接口和接 1G 到 10G 的 SFP+ 接口。</p><p>雖然兩種制式的接口都一樣，但並一定不通用，部分交換機 SFP 接口同時支持兼容 SFP+。</p><h2 id=\"接口種類\"><a href=\"#接口種類\" class=\"headerlink\" title=\"接口種類\"></a>接口種類</h2><p>SFP 接口的種類可以從速率，光波長，傳送距離，光端接口，單模/雙模，單纖雙向(BiDi)/雙纖，端面。</p><h3 id=\"速率\"><a href=\"#速率\" class=\"headerlink\" title=\"速率\"></a>速率</h3><p>按照速率分類：有155M/622M/1.25G/2.125G/4.25G/8G/10G，常見的有155M/1.25G/2.125G/10G。</p><h3 id=\"波長\"><a href=\"#波長\" class=\"headerlink\" title=\"波長\"></a>波長</h3>","keywords":null,"content":null,"text":"SFP接口現時的路由器/交換器在需要接入光纖的時候，一般需要使用上 SFP 接口。SFP 的接口比上一代的 GBIC 接口要小一點，這樣前端面版就可以接入更多的光纖。SFP 接口分別有兩種制式，接 1G 或以下的 SFP 接口和接 1G 到 10G 的 SFP+ 接口。雖然兩種制","link":"","raw":null,"photos":["/2019/01/03/選擇SFP的ONU端口/cjpxtivk100024b8hkbz4kt4z.720p.jpg"],"source":"_posts/2019/01/03-選擇SFP的ONU端口.md","categories":[{"name":"Network","slug":"Network","count":1,"path":"api/categories/Network.json"}],"tags":[]},{"_id":"cjqdka8yf0000molr1hp619l7","title":"當年今日","slug":"當年今日","date":"2019-01-01T10:54:24.000Z","updated":"2019-01-01T09:39:25.911Z","comments":true,"permalink":"/2019/01/01/當年今日/","path":"api/articles/當年今日.json","excerpt":"<iframe width=\"100%\" height=\"525\" src=\"https://www.youtube.com/embed/URUIcYDq3_I?controls=0\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe><p><code>很多時候，選擇並不需要經過多麼理性的思考。</code></p><p><code>困難的其實並非是選擇本身，而是思考選擇的過程。</code></p><p><code>現實不可能如此理想化，因此達成理想的途徑不可能脫離現實。</code></p><p><code>對於現實我們無能為力，我們只能依靠合理的規則使現實不至於脫軌，並且讓現實成為動力。</code></p><p><code>不要試圖以長期的理想去思考解決短期問題的辦法，這是一種妥協。</code></p><p><code>回憶是用以憑吊的，不是用來沈溺的。</code></p><p><code>就算有一天我們都會老去，至少到時我們回憶過去的時候，會為了自己曾經做過的事微笑，這樣就足夠了。</code></p><p>2018 年裹，經歷的事不算太多。但經歷的事算是人生的轉捩點。</p><p>生亦何歡，死亦何苦？如何構成「有意義」的人生，人生的意義在不同時段都有不同的失落，</p>","keywords":null,"content":null,"text":"很多時候，選擇並不需要經過多麼理性的思考。困難的其實並非是選擇本身，而是思考選擇的過程。現實不可能如此理想化，因此達成理想的途徑不可能脫離現實。對於現實我們無能為力，我們只能依靠合理的規則使現實不至於脫軌，並且讓現實成為動力。不要試圖以長期的理想去思考解決短期問題的辦法，這是一種","link":"","raw":null,"photos":["/2019/01/01/當年今日/photo_2019-01-01_15-22-38.jpg"],"source":"_posts/2019/01/01-當年今日.md","categories":[],"tags":[]},{"_id":"cjpv7aphr0000iwueda1msn65","title":"Angular/Element(Web Components)","slug":"Angular-Element-Web-Components","date":"2018-12-19T17:39:31.000Z","updated":"2018-12-19T13:16:13.455Z","comments":true,"permalink":"/2018/12/19/Angular-Element-Web-Components/","path":"api/articles/Angular-Element-Web-Components.json","excerpt":"<h2 id=\"Web-Components\"><a href=\"#Web-Components\" class=\"headerlink\" title=\"Web Components\"></a>Web Components</h2><p>Web Components 是最新的 HTML 技術，這項技術可以令瀏覽器支持原生的自定組件，這種做法就可以減輕對前端的依賴/需求。</p><p>別外，使用 web components 可以代替組件在網頁上 JIT 編譯，減小瀏覽器的壓力。</p><h2 id=\"在Angular-上使用-Web-Component\"><a href=\"#在Angular-上使用-Web-Component\" class=\"headerlink\" title=\"在Angular 上使用 Web Component\"></a>在Angular 上使用 Web Component</h2><h3 id=\"安裝\"><a href=\"#安裝\" class=\"headerlink\" title=\"安裝\"></a>安裝</h3><p>首先在項目目錄下安裝 <code>@angular/elements</code></p><p>之後把 <code>document-register-element</code> 更新</p><p>別外，為了支持舊版本的瀏覽器，需要加入兼容器 (polyfill) <code>@webcomponents/webcomponentsjs</code></p><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ng add @angular/elements</span><br><span class=\"line\">yarn add document-register-element</span><br><span class=\"line\">yarn add @webcomponents/webcomponentsjs</span><br></pre></td></tr></table></figure><p>之後在 <code>polyfills.ts</code> 載入</p>","keywords":null,"content":null,"text":"Web ComponentsWeb Components 是最新的 HTML 技術，這項技術可以令瀏覽器支持原生的自定組件，這種做法就可以減輕對前端的依賴/需求。別外，使用 web components 可以代替組件在網頁上 JIT 編譯，減小瀏覽器的壓力。在Angular 上使","link":"","raw":null,"photos":["/2018/12/19/Angular-Element-Web-Components/cjps7ommi000j4u8hgkgz78k4.720p.jpg"],"source":"_posts/2018/12/19-Angular-Element-Web-Components.md","categories":[],"tags":[]}]}