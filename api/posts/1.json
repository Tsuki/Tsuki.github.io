{"total":69,"pageSize":10,"pageCount":7,"data":[{"_id":"ck1roeoun0000mumcnhp0sviq","title":"Netty 踏坑之路","slug":"Netty-踏坑之路","date":"2019-10-15T10:39:45.000Z","updated":"2019-10-15T10:00:20.688Z","comments":true,"permalink":"/2019/10/15/Netty-踏坑之路/","path":"api/articles/Netty-踏坑之路.json","excerpt":"<h2 id=\"Bytebuf\"><a href=\"#Bytebuf\" class=\"headerlink\" title=\"Bytebuf\"></a>Bytebuf</h2><p>Bytebuf 是 Netty 內部的一個處理原始數據類型，這個類型會針會 jvm 的回收機制優化同時抽象出 zero-copy 的數據類型。</p><h4 id=\"readSlice-vs-readBytes\"><a href=\"#readSlice-vs-readBytes\" class=\"headerlink\" title=\"readSlice vs readBytes\"></a>readSlice vs readBytes</h4><p>readSlice 是反正 Bytebuf的 視圖，但建立自己的 readIndex 和 writeIndex. 在視圖讀寫數據不會影響本來的Index.</p><p>readBytes 是返回新的 Bytebuf，申請後 需要自行 release 以釋放數據，除止內存洩漏。</p><h4 id=\"slice-vs-duplicate-vs-copy\"><a href=\"#slice-vs-duplicate-vs-copy\" class=\"headerlink\" title=\"slice vs duplicate vs copy\"></a>slice vs duplicate vs copy</h4><ol><li>slice() 方法從原始 ByteBuf 中截取一段，這段數據是從 readerIndex 到 writeIndex，同時，返回的新的 ByteBuf 的最大容量 maxCapacity 為原始 ByteBuf 的 readableBytes()</li><li>duplicate() 方法把整個 ByteBuf 都截取出來，包括所有的數據，指針信息</li><li>slice() 方法與 duplicate() 方法的相同點是：底層內存以及引用計數與原始的 ByteBuf 共享，也就是說經過 slice() 或者 duplicate() 返回的 ByteBuf 調用 write 系列方法都會影響到 原始的 ByteBuf，但是它們都維持著與原始 ByteBuf 相同的內存引用計數和不同的讀寫指針</li><li>slice() 方法與 duplicate() 不同點就是：slice() 只截取從 readerIndex 到 writerIndex 之間的數據，它返回的 ByteBuf 的最大容量被限制到 原始 ByteBuf 的 readableBytes(), 而 duplicate() 是把整個 ByteBuf 都與原始的 ByteBuf 共享</li><li>slice() 方法與 duplicate() 方法不會拷貝數據，它們只是通過改變讀寫指針來改變讀寫的行為，而最後一個方法 copy() 會直接從原始的 ByteBuf 中拷貝所有的信息，包括讀寫指針以及底層對應的數據，因此，往 copy() 返回的 ByteBuf 中寫數據不會影響到原始的 ByteBuf</li><li>slice() 和 duplicate() 不會改變 ByteBuf 的引用計數，所以原始的 ByteBuf 調用 release() 之後發現引用計數為零，就開始釋放內存，調用這兩個方法返回的 ByteBuf 也會被釋放，這個時候如果再對它們進行讀寫，就會報錯。因此，我們可以通過調用一次 retain() 方法 來增加引用，表示它們對應的底層的內存多了一次引用，引用計數為2，在釋放內存的時候，需要調用兩次 release() 方法，將引用計數降到零，才會釋放內存</li><li>這三個方法均維護著自己的讀寫指針，與原始的 ByteBuf 的讀寫指針無關，相互之間不受影響</li></ol><p>Ref：</p><p><a href=\"https://my.oschina.net/funcy/blog/2250198\" target=\"_blank\" rel=\"noopener\">数据传输载体 ByteBuf 介绍</a></p>","keywords":null,"content":null,"text":"BytebufBytebuf 是 Netty 內部的一個處理原始數據類型，這個類型會針會 jvm 的回收機制優化同時抽象出 zero-copy 的數據類型。readSlice vs readBytesreadSlice 是反正 Bytebuf的 視圖，但建立自己的 readInd","link":"","raw":null,"photos":[],"source":"_posts/2019/10/15-Netty-踏坑之路.md","categories":[],"tags":[]},{"_id":"cjxy83ur30000iuqvimd7k64c","title":"JS不可變物件","slug":"JS不可變物件","date":"2019-07-11T11:26:18.000Z","updated":"2019-07-11T05:19:45.966Z","comments":true,"permalink":"/2019/07/11/JS不可變物件/","path":"api/articles/JS不可變物件.json","excerpt":"<h1 id=\"在JS應對髒值檢查\"><a href=\"#在JS應對髒值檢查\" class=\"headerlink\" title=\"在JS應對髒值檢查\"></a>在JS應對髒值檢查</h1><p>在不同前端框架中都有各自的髒值發現算法，而大多數都是基於引用對比。</p><p>在一般數值或字串，這種原生物件/類型上，都是不可變的。因此每次改變都會更新其引用/指針，除了數組和物件(Array,Object)這兩個特殊的類件。</p><p>使用 <code>Array.push</code> 和 <code>Array.splice</code> 或直更改 Object 的內容，都是基於子物件/子類型的內容，並不會對根引用/針對作出變更。因此大部分情況下，都不會觸發髒值檢查。</p><p>如果要對 Array 和 Object 重新構造，可以使用以下方法。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// es5</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> rawArray = [<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> rawObject = &#123;<span class=\"attr\">a</span>:<span class=\"string\">'a'</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> newArray = [].concat(rawArray);</span><br><span class=\"line\"><span class=\"keyword\">const</span> newObject = <span class=\"built_in\">Object</span>.assign(&#123;&#125;, rawObject);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rawArray === newArray); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rawObject === newObject); <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// es6</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> newES6Array = [...rawArray];</span><br><span class=\"line\"><span class=\"keyword\">const</span> pushArray = [...rawArray, <span class=\"number\">7</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> unshiftArray = [<span class=\"number\">7</span>, ...rawArray];</span><br><span class=\"line\"><span class=\"keyword\">const</span> newES6Object = &#123;...rawObject&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rawArray === unshiftArray); <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(rawObject === newES6Object); <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure><p>別了以上的方法構建新的實例外，別一做法是使用 getter 返回一個全新的類型。</p><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">title = <span class=\"string\">'title'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">objTitle = &#123;</span><br><span class=\"line\">  title: <span class=\"keyword\">this</span>.title === <span class=\"string\">'title'</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">get getterObjTitle() &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'getterObj'</span>, <span class=\"keyword\">this</span>.obj.title);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    title: <span class=\"keyword\">this</span>.title === <span class=\"string\">'title'</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>以上方法如果直接拿objTitle是不會得到更新。</p>","keywords":null,"content":null,"text":"在JS應對髒值檢查在不同前端框架中都有各自的髒值發現算法，而大多數都是基於引用對比。在一般數值或字串，這種原生物件/類型上，都是不可變的。因此每次改變都會更新其引用/指針，除了數組和物件(Array,Object)這兩個特殊的類件。使用 Array.push 和 Array.sp","link":"","raw":null,"photos":[],"source":"_posts/2019/07/11-JS不可變物件.md","categories":[{"name":"JavaScript","slug":"JavaScript","count":2,"path":"api/categories/JavaScript.json"}],"tags":[]},{"_id":"cjxdbk8cp0001mvk69ppnmmmn","title":"處理圖像的TypedArray和一般的UInt8Array區別","slug":"處理圖像的TypedArray和一般的UInt8Array區別","date":"2019-06-26T21:05:49.000Z","updated":"2019-06-26T14:13:07.012Z","comments":true,"permalink":"/2019/06/26/處理圖像的TypedArray和一般的UInt8Array區別/","path":"api/articles/處理圖像的TypedArray和一般的UInt8Array區別.json","excerpt":"<p>在 ES2015上加入了 TypedArray 的處理，以處理 buffer 帶來的問題，而其中 Uint8 有兩種類型和處理方法，分別是Uint8Array，Uint8ClampedArray。</p><p>前者是無條件捨去小數（ToUint8），後者是使用奇進偶捨（ToUint8Clamp ）的進位方法。</p><p>其次前者不會對二補位的負數作溢出處理，後者會對小於０和大於２５５的數字作出歸０或２５５。</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Int8Array();</span><br><span class=\"line\">Uint8Array();</span><br><span class=\"line\">Uint8ClampedArray();</span><br><span class=\"line\">Int16Array();</span><br><span class=\"line\">Uint16Array();</span><br><span class=\"line\">Int32Array();</span><br><span class=\"line\">Uint32Array();</span><br><span class=\"line\">Float32Array();</span><br><span class=\"line\">Float64Array();</span><br><span class=\"line\">BigInt64Array();</span><br><span class=\"line\">BigUint64Array();</span><br></pre></td></tr></table></figure><p>別外在<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/ImageData/ImageData\" target=\"_blank\" rel=\"noopener\"><code>ImageData()</code></a>的 <code>array</code> 是注明 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray\" target=\"_blank\" rel=\"noopener\"><code>Uint8ClampedArray</code></a> 。</p><h3 id=\"ToUint8-argument\"><a href=\"#ToUint8-argument\" class=\"headerlink\" title=\"ToUint8 ( argument )\"></a>ToUint8 ( argument )</h3><p>The abstract operation ToUint8 converts argument to one of 28 integer values in the range 0 through 255, inclusive. This abstract operation functions as follows:</p><ol><li>Let <em>number</em> be <a href=\"http://www.ecma-international.org/ecma-262/6.0/index.html#sec-tonumber\" target=\"_blank\" rel=\"noopener\">ToNumber</a>(<em>argument</em>).</li><li><a href=\"http://www.ecma-international.org/ecma-262/6.0/index.html#sec-returnifabrupt\" target=\"_blank\" rel=\"noopener\">ReturnIfAbrupt</a>(<em>number</em>).</li><li>If <em>number</em> is <strong>NaN</strong>, <strong>+0</strong>, <strong>−0</strong>, <strong>+∞</strong>, or <strong>−∞</strong>, return <strong>+0</strong>.</li><li>Let <em>int</em> be the mathematical value that is the same sign as <em>number</em> and whose magnitude is <a href=\"http://www.ecma-international.org/ecma-262/6.0/index.html#sec-algorithm-conventions\" target=\"_blank\" rel=\"noopener\">floor</a>(<a href=\"http://www.ecma-international.org/ecma-262/6.0/index.html#sec-algorithm-conventions\" target=\"_blank\" rel=\"noopener\">abs</a>(<em>number</em>)).</li><li>Let <em>int8bit</em> be <em>int</em> <a href=\"http://www.ecma-international.org/ecma-262/6.0/index.html#sec-algorithm-conventions\" target=\"_blank\" rel=\"noopener\">modulo</a> 28.</li><li>Return <em>int8bit</em>.</li></ol><h3 id=\"ToUint8Clamp-argument\"><a href=\"#ToUint8Clamp-argument\" class=\"headerlink\" title=\"ToUint8Clamp ( argument )\"></a>ToUint8Clamp ( argument )</h3><p>The abstract operation ToUint8Clamp converts argument to one of 28 integer values in the range 0 through 255, inclusive. This abstract operation functions as follows:</p>","keywords":null,"content":null,"text":"在 ES2015上加入了 TypedArray 的處理，以處理 buffer 帶來的問題，而其中 Uint8 有兩種類型和處理方法，分別是Uint8Array，Uint8ClampedArray。前者是無條件捨去小數（ToUint8），後者是使用奇進偶捨（ToUint8Clamp","link":"","raw":null,"photos":[],"source":"_posts/2019/06/26-處理圖像的TypedArray和一般的UInt8Array區別.md","categories":[{"name":"JavaScript","slug":"JavaScript","count":2,"path":"api/categories/JavaScript.json"}],"tags":[]},{"_id":"cjxdbk87o0000mvk6oer7bp5x","title":"Tensorflow尋找Tensor節點","slug":"Tensorflow尋找Tensor節點","date":"2019-06-26T20:12:18.000Z","updated":"2019-06-26T14:13:07.012Z","comments":true,"permalink":"/2019/06/26/Tensorflow尋找Tensor節點/","path":"api/articles/Tensorflow尋找Tensor節點.json","excerpt":"<p>在一個 Tensorflow model 上截取入口點和出口點 可以在載入 graph 後提取出所有節點的名字。</p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tf.import_graph_def(graph_def, name=<span class=\"string\">\"\"</span>)</span><br><span class=\"line\">pp([tensor.name <span class=\"keyword\">for</span> tensor <span class=\"keyword\">in</span> tf.compat.v1.get_default_graph().as_graph_def().node])</span><br></pre></td></tr></table></figure>","keywords":null,"content":null,"text":"在一個 Tensorflow model 上截取入口點和出口點 可以在載入 graph 後提取出所有節點的名字。1<br>2<br>tf.import_graph_def(graph_def, name=\"\")<br>pp([tensor.name for tensor in t","link":"","raw":null,"photos":[],"source":"_posts/2019/06/26-Tensorflow尋找Tensor節點.md","categories":[{"name":"Tensorflow","slug":"Tensorflow","count":1,"path":"api/categories/Tensorflow.json"}],"tags":[]},{"_id":"cjugy0vku0000ilp4glt1f9no","title":"記一次使用 Makefile 和 Docker 的坑","slug":"記一次使用-makefile-和-docker-的坑","date":"2019-04-13T20:00:07.000Z","updated":"2019-04-14T13:06:14.198Z","comments":true,"permalink":"/2019/04/13/記一次使用-makefile-和-docker-的坑/","path":"api/articles/記一次使用-makefile-和-docker-的坑.json","excerpt":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>在使用 make 和 Docker 構建發佈影像時，重構了一下 Makefile 而引起不算是 Bug 的 bug.</p><h3 id=\"事原\"><a href=\"#事原\" class=\"headerlink\" title=\"事原\"></a>事原</h3><p>Makefile 指令如果在用同的文件夾突特時 會出現 <code>make: 指令 is up to date.</code> 這樣奇怪的信訊？（？</p><p>別外加上在 Docker build 的時候 make 指令的 step 出現 up to date 以為是被 cached。</p><p>最後在 <code>COPY --from=build-dev</code> 時找不到文件 出現 <code>/var/lib/docker/overlay2/</code> 找不到文件 而不是在 docker 對應路徑。</p><h3 id=\"解決\"><a href=\"#解決\" class=\"headerlink\" title=\"解決\"></a>解決</h3><p>在 Makefile 裹給指令 加上 <code>.PHONY</code> 注解。</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A phony target is one that is not really the name of a file; rather it is just a name for a recipe to be executed when you make an explicit request. There are two reasons to use a phony target: to avoid a conflict with a file of the same name, and to improve performance.</span><br><span class=\"line\"></span><br><span class=\"line\">If you write a rule whose recipe will not create the target file, the recipe will be executed every time the target comes up for remaking.</span><br></pre></td></tr></table></figure><p>GNU默认makefile target是一个文件，因此他会先检测同级目录下是否已存在这个文件，如果存在，则会abort掉make 进程，但目标不是文件的话，则会出现up to date的情况，这种情况需要.PHONY来避免问题的出现，phony的意思是“赝品”，在这里可以形象的理解成“不是文件”。</p>","keywords":null,"content":null,"text":"前言在使用 make 和 Docker 構建發佈影像時，重構了一下 Makefile 而引起不算是 Bug 的 bug.事原Makefile 指令如果在用同的文件夾突特時 會出現 make: 指令 is up to date. 這樣奇怪的信訊？（？別外加上在 Docker bui","link":"","raw":null,"photos":[],"source":"_posts/2019/04/13-記一次使用-makefile-和-docker-的坑.md","categories":[{"name":"Docker","slug":"Docker","count":1,"path":"api/categories/Docker.json"},{"name":"Linux","slug":"Docker/Linux","count":1,"path":"api/categories/Docker/Linux.json"}],"tags":[]},{"_id":"cju2ndcof0005itmguh1qumro","title":"把OPENSSL 私鑰轉換成 RSA 私鈅","slug":"把OPENSSL-私鑰轉換成-RSA-私鈅","date":"2019-04-04T19:43:03.000Z","updated":"2019-04-04T12:59:22.508Z","comments":true,"permalink":"/2019/04/04/把OPENSSL-私鑰轉換成-RSA-私鈅/","path":"api/articles/把OPENSSL-私鑰轉換成-RSA-私鈅.json","excerpt":"<h2 id=\"事原\"><a href=\"#事原\" class=\"headerlink\" title=\"事原\"></a>事原</h2><p>由於 OpenSSH version 7.9p1 修改了 預設的私鑰輸出格式，</p><p>從 <code>-----BEGIN RSA PRIVATE KEY-----</code> 改成 <code>-----BEGIN OPENSSH PRIVATE KEY-----</code></p><p>所以 Jetbrain 的全家桶都不能讀取正確的私鑰。</p><h3 id=\"指令-把原有的私鑰-重新導出\"><a href=\"#指令-把原有的私鑰-重新導出\" class=\"headerlink\" title=\"指令 - 把原有的私鑰 重新導出\"></a>指令 - 把原有的私鑰 重新導出</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp ~/.ssh/id_rsa ~/.ssh/id_rsa.bak</span><br><span class=\"line\">ssh-keygen -p -m PEM -f ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><h3 id=\"指令-重新生成新的-PEM-格式私鑰\"><a href=\"#指令-重新生成新的-PEM-格式私鑰\" class=\"headerlink\" title=\"指令 - 重新生成新的 PEM 格式私鑰\"></a>指令 - 重新生成新的 PEM 格式私鑰</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp ~/.ssh/id_rsa ~/.ssh/id_rsa.bak</span><br><span class=\"line\"></span><br><span class=\"line\">ssh-keygen -m PEM -C &quot;email&quot;</span><br><span class=\"line\">或</span><br><span class=\"line\">ssh-keygen -t rsa -b 4096 -m pem -C &quot;email&quot;</span><br></pre></td></tr></table></figure>","keywords":null,"content":null,"text":"事原由於 OpenSSH version 7.9p1 修改了 預設的私鑰輸出格式，從 -----BEGIN RSA PRIVATE KEY----- 改成 -----BEGIN OPENSSH PRIVATE KEY-----所以 Jetbrain 的全家桶都不能讀取正確的私鑰。","link":"","raw":null,"photos":[],"source":"_posts/2019/04/04-把OPENSSL-私鑰轉換成-RSA-私鈅.md","categories":[],"tags":[]},{"_id":"cju2ndcof0004itmg0kd09oa7","title":"SS PAC模式白名單","slug":"Shadowsocks-白名單","date":"2019-03-05T20:36:46.000Z","updated":"2019-04-04T12:59:22.508Z","comments":true,"permalink":"/2019/03/05/Shadowsocks-白名單/","path":"api/articles/Shadowsocks-白名單.json","excerpt":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>使用 SS 但又不想使用全局，避免大量跑光流量，需要定制白名單給 google / youtube。</p><h1 id=\"白名單制作\"><a href=\"#白名單制作\" class=\"headerlink\" title=\"白名單制作\"></a>白名單制作</h1><p>由於 SS 沒有自帶白名單模式，而且自帶的 gfwlist.txt 內有避開國內的域名，所以需要先制作一分全局的 gfwlist.txt</p><p><code>||*</code> 是全局的規則，我們需要先做base64處理，下面是處理好的 <code>gfwlist.txt</code> 和 gist 地址。</p><p>之後需要放到 Github 或其他地方寄存。</p><script src=\"https://gist.github.com/Tsuki/67e448466baf453a9a9eca4a6d55592a.js\"></script><p><a href=\"https://gist.githubusercontent.com/Tsuki/67e448466baf453a9a9eca4a6d55592a/raw/4e262236bf1cb21348612274fbd5b5cf3da1afe7/sswl.txt\" target=\"_blank\" rel=\"noopener\">https://gist.githubusercontent.com/Tsuki/67e448466baf453a9a9eca4a6d55592a/raw/4e262236bf1cb21348612274fbd5b5cf3da1afe7/sswl.txt</a></p><p>之後在 User-rule 下加入想要白名單的域名。</p><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@@googlevideo.com</span><br><span class=\"line\">@@youtube.com</span><br><span class=\"line\">@@google.com</span><br><span class=\"line\">@@ytimg.com</span><br></pre></td></tr></table></figure>","keywords":null,"content":null,"text":"前言使用 SS 但又不想使用全局，避免大量跑光流量，需要定制白名單給 google / youtube。白名單制作由於 SS 沒有自帶白名單模式，而且自帶的 gfwlist.txt 內有避開國內的域名，所以需要先制作一分全局的 gfwlist.txt||* 是全局的規則，我們需要","link":"","raw":null,"photos":[],"source":"_posts/2019/03/05-Shadowsocks-白名單.md","categories":[],"tags":[]},{"_id":"cju2ndcod0002itmgp8vj8c1d","title":"Async/Await Golang式寫法","slug":"Async-Await-golang式寫法","date":"2019-02-09T11:28:10.000Z","updated":"2019-04-04T12:59:22.508Z","comments":true,"permalink":"/2019/02/09/Async-Await-golang式寫法/","path":"api/articles/Async-Await-golang式寫法.json","excerpt":"<p>使用 promise 和 result pair 避免 try-catch style.</p><p>Javascript 例子</p><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// to.ts</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">to</span>(<span class=\"params\">promise: <span class=\"built_in\">Promise</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> promise</span><br><span class=\"line\">        .then(<span class=\"function\"><span class=\"params\">data</span> =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> [<span class=\"literal\">null</span>, data];</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .catch(<span class=\"function\"><span class=\"params\">err</span> =&gt;</span> [err]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><figure class=\"highlight typescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> to <span class=\"keyword\">from</span> <span class=\"string\">'to'</span>;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">class</span> AccountComponent <span class=\"keyword\">implements</span> OnInit, OnChanges&#123;</span><br><span class=\"line\">    <span class=\"keyword\">async</span> ngOnChanges(changes: SimpleChanges) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// TODO check change</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> err, result;</span><br><span class=\"line\">        [err, result] = <span class=\"keyword\">await</span> to(<span class=\"keyword\">this</span>.httpService.listAccount(<span class=\"keyword\">this</span>.data).toPromise());</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (err != <span class=\"literal\">null</span> &amp;&amp; err <span class=\"keyword\">instanceof</span> HttpErrorResponse) &#123;</span><br><span class=\"line\">          <span class=\"comment\">// err in</span></span><br><span class=\"line\">          <span class=\"keyword\">this</span>.notice.create(<span class=\"string\">'error'</span>, err.error.msg);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>以下是 Golang 的寫法</p><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> err, result := httpService.listAccount(data); err != <span class=\"literal\">nil</span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// process...</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// error handling...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><a href=\"https://blog.grossman.io/how-to-write-async-await-without-try-catch-blocks-in-javascript/\" target=\"_blank\" rel=\"noopener\">How to write async await without try-catch blocks in Javascript - dima</a></p><p><a href=\"https://segmentfault.com/a/1190000011802045\" target=\"_blank\" rel=\"noopener\">从不用 try-catch 实现的 async/await 语法说错误处理</a></p><p>題外話 – try-catch 的惡魔</p><p><a href=\"http://teddy-chen-tw.blogspot.com/2011/05/checked-or-unchecked-exceptions-1.html\" target=\"_blank\" rel=\"noopener\">Checked or unchecked exceptions (1)</a></p>","keywords":null,"content":null,"text":"使用 promise 和 result pair 避免 try-catch style.Javascript 例子1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>// to.ts<br>export default function to(prom","link":"","raw":null,"photos":[],"source":"_posts/2019/02/09-Async-Await-golang式寫法.md","categories":[],"tags":[]},{"_id":"cju2ndcn50001itmgxs935t3j","title":"Android 中文在地化機制","slug":"Android-中文在地化機制","date":"2019-02-02T12:03:44.000Z","updated":"2019-04-04T12:59:22.508Z","comments":true,"permalink":"/2019/02/02/Android-中文在地化機制/","path":"api/articles/Android-中文在地化機制.json","excerpt":"<h3 id=\"在-Andorid-7-之前，\"><a href=\"#在-Andorid-7-之前，\" class=\"headerlink\" title=\"在 Andorid 7 之前，\"></a>在 Andorid 7 之前，</h3><ul><li><code>zh-CN</code> (簡體)</li><li><code>zh-TW</code> (繁體)</li><li>特殊子集:<ul><li><code>zh-SG</code> (簡體)</li><li><code>zh-HK</code> (繁體)</li><li><code>zh-MO</code> (繁體)</li></ul></li></ul><h3 id=\"在-Android-7-及之後，-喵喵喵？\"><a href=\"#在-Android-7-及之後，-喵喵喵？\" class=\"headerlink\" title=\"在 Android 7 及之後，(喵喵喵？)\"></a>在 Android 7 及之後，(喵喵喵？)</h3><ul><li><code>zh-Hans-CN</code> (簡體)</li><li><code>zh-Hans-MO</code> (簡體)</li><li><code>zh-Hans-HK</code> (簡體)</li><li><code>zh-Hans-SG</code> (簡體)</li><li><code>zh-Hant-TW</code> (繁體)</li><li><code>zh-Hant-HK</code> (繁體)</li><li><code>zh-Hant-MO</code> (繁體)</li></ul><p>###Android 7 Fallback 機制</p><p><code>zh-Hans-*</code> 退回到 <code>zh</code></p><p><code>zh-Hant-*</code> 退回到 <code>zh-Hant (zh-rTW)</code></p><p>而 <code>zh-Hans-MO</code> 和 <code>zh-Hans-HK</code> 需要指定 <code>values-b+zh+Hans+HK/MO</code> 再退回 <code>zh-Hans-*</code> 處理</p><p><a href=\"https://gist.github.com/amake/0ac7724681ac1c178c6f95a5b09f03ce#new-locales-vs-old-locales-chinese\" target=\"_blank\" rel=\"noopener\">Correct localization on Android 7</a></p><p><a href=\"https://developer.android.com/guide/topics/resources/multilingual-support\" target=\"_blank\" rel=\"noopener\">Language and locale resolution overview</a></p>","keywords":null,"content":null,"text":"在 Andorid 7 之前，zh-CN (簡體)zh-TW (繁體)特殊子集:zh-SG (簡體)zh-HK (繁體)zh-MO (繁體)在 Android 7 及之後，(喵喵喵？)zh-Hans-CN (簡體)zh-Hans-MO (簡體)zh-Hans-HK (簡體)zh-","link":"","raw":null,"photos":[],"source":"_posts/2019/02/02-Android-中文在地化機制.md","categories":[],"tags":[]},{"_id":"cju2ndcoe0003itmgdvroyup0","title":"Android 文件保存和索引","slug":"Android-文件保存和索引","date":"2019-02-02T12:02:58.000Z","updated":"2019-04-04T12:59:22.508Z","comments":true,"permalink":"/2019/02/02/Android-文件保存和索引/","path":"api/articles/Android-文件保存和索引.json","excerpt":"<h3 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h3><p>Android 在保存文件後，如果不在索引目錄下是不會自動建立索引，需要調用 <code>MediaScanner</code> 發出一個廣播和指定目錄或文件的指令才會實行。</p><p>實作 <code>MediaScannerConnectionClient</code> 類，發出掃描指令並在完成後斷開連接。</p><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SingleMediaScanner</span></span>(<span class=\"keyword\">val</span> context: Context, <span class=\"keyword\">val</span> file: File) :</span><br><span class=\"line\">  MediaScannerConnection.MediaScannerConnectionClient &#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"keyword\">val</span> mediaScannerConnection</span><br><span class=\"line\">    <span class=\"keyword\">by</span> lazy &#123; MediaScannerConnection(context, <span class=\"keyword\">this</span>) &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onMediaScannerConnected</span><span class=\"params\">()</span></span> =</span><br><span class=\"line\">    mediaScannerConnection.scanFile(file.absolutePath, <span class=\"literal\">null</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">override</span> <span class=\"function\"><span class=\"keyword\">fun</span> <span class=\"title\">onScanCompleted</span><span class=\"params\">(path: <span class=\"type\">String</span>?, uri: <span class=\"type\">Uri</span>?)</span></span> =</span><br><span class=\"line\">    mediaScannerConnection.disconnect()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">fun</span> Context.<span class=\"title\">takeScreenshot</span><span class=\"params\">(bitmap: <span class=\"type\">Bitmap</span>)</span></span>: String? &#123;</span><br><span class=\"line\">  <span class=\"keyword\">val</span> mediaStorageDir = Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES)</span><br><span class=\"line\">  <span class=\"keyword\">val</span> timestamp = SimpleDateFormat(<span class=\"string\">\"yyyyMMdd_HHmmss\"</span>).format(Date())</span><br><span class=\"line\">  <span class=\"keyword\">val</span> mediaFile = File(<span class=\"string\">\"<span class=\"subst\">$&#123;mediaStorageDir.path&#125;</span><span class=\"subst\">$&#123;File.separator&#125;</span><span class=\"variable\">$timestamp</span>.jpg\"</span>)</span><br><span class=\"line\">  <span class=\"keyword\">var</span> compress = <span class=\"literal\">false</span></span><br><span class=\"line\">  doAsync &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!mediaStorageDir.exists() &amp;&amp; !mediaStorageDir.mkdirs()) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span><span class=\"symbol\">@doAsync</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Timber.d(<span class=\"string\">\"screenshot: file <span class=\"subst\">$&#123;mediaStorageDir.path&#125;</span><span class=\"subst\">$&#123;File.separator&#125;</span><span class=\"variable\">$timestamp</span>.jpg\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">val</span> fos = FileOutputStream(mediaFile)</span><br><span class=\"line\">    compress = bitmap.compress(Bitmap.CompressFormat.JPEG, <span class=\"number\">90</span>, fos)</span><br><span class=\"line\">    fos.close()</span><br><span class=\"line\">    SingleMediaScanner(<span class=\"keyword\">this</span><span class=\"symbol\">@takeScreenshot</span>, mediaStorageDir)</span><br><span class=\"line\">  &#125;.<span class=\"keyword\">get</span>()</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">if</span> (compress) mediaFile.toString() <span class=\"keyword\">else</span> <span class=\"literal\">null</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","keywords":null,"content":null,"text":"索引Android 在保存文件後，如果不在索引目錄下是不會自動建立索引，需要調用 MediaScanner 發出一個廣播和指定目錄或文件的指令才會實行。實作 MediaScannerConnectionClient 類，發出掃描指令並在完成後斷開連接。1<br>2<br>3<br","link":"","raw":null,"photos":[],"source":"_posts/2019/02/02-Android-文件保存和索引.md","categories":[],"tags":[]}]}